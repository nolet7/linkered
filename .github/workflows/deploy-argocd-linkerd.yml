name: Deploy Linkerd via Argo CD

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: Environment to deploy
        default: dev
        options: [dev, staging, prod]
  push:
    branches: [ master ]
    paths:
      - 'argocd/**'
      - 'helm-values/**'
      - '.github/workflows/deploy-argocd-linkerd.yml'

env:
  PROJECT_ID: idp-0903
  GKE_CLUSTER: lowcost-gke-ondemand
  GKE_ZONE: us-central1-a
  DEFAULT_BRANCH: master

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # gcloud + auth
      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '>= 475.0.0'

      - name: Auth with service account
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Install GKE auth plugin
        run: gcloud components install gke-gcloud-auth-plugin -q

      - name: Get GKE credentials
        run: |
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
          gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_ZONE" --project "$PROJECT_ID"

      # ---------- Create identity material FIRST (Secret+CM) ----------
      # dev: generate ephemeral CA/issuer; staging/prod: use GitHub Secrets
      - name: Prepare Linkerd identity material (Secret/ConfigMap)
        env:
          ENV: ${{ github.event.inputs.environment || 'dev' }}
          STAGING_TA:   ${{ secrets.LINKERD_STAGING_TRUST_ANCHOR_PEM }}
          STAGING_CERT: ${{ secrets.LINKERD_STAGING_ISSUER_CERT_PEM }}
          STAGING_KEY:  ${{ secrets.LINKERD_STAGING_ISSUER_KEY_PEM }}
          PROD_TA:      ${{ secrets.LINKERD_PROD_TRUST_ANCHOR_PEM }}
          PROD_CERT:    ${{ secrets.LINKERD_PROD_ISSUER_CERT_PEM }}
          PROD_KEY:     ${{ secrets.LINKERD_PROD_ISSUER_KEY_PEM }}
        run: |
          set -euo pipefail
          kubectl get ns linkerd >/dev/null 2>&1 || kubectl create ns linkerd

          if [ "$ENV" = "dev" ]; then
            mkdir -p /tmp/linkerd-dev
            # Trust anchor (self-signed)
            openssl req -x509 -newkey rsa:4096 -days 3650 -nodes \
              -keyout /tmp/linkerd-dev/ca.key -out /tmp/linkerd-dev/trust-anchor.crt \
              -subj "/CN=linkerd-trust-anchor.dev"
            # Issuer signed by trust anchor
            openssl req -new -newkey rsa:4096 -nodes \
              -keyout /tmp/linkerd-dev/issuer.key -out /tmp/linkerd-dev/issuer.csr \
              -subj "/CN=linkerd-identity-issuer.dev"
            openssl x509 -req -in /tmp/linkerd-dev/issuer.csr \
              -CA /tmp/linkerd-dev/trust-anchor.crt -CAkey /tmp/linkerd-dev/ca.key -CAcreateserial \
              -out /tmp/linkerd-dev/issuer.crt -days 3650

            TA_PEM="$(cat /tmp/linkerd-dev/trust-anchor.crt)"
            CRT_PEM="$(cat /tmp/linkerd-dev/issuer.crt)"
            KEY_PEM="$(cat /tmp/linkerd-dev/issuer.key)"
          else
            case "$ENV" in
              staging) TA_PEM="$STAGING_TA"; CRT_PEM="$STAGING_CERT"; KEY_PEM="$STAGING_KEY" ;;
              prod)    TA_PEM="$PROD_TA";    CRT_PEM="$PROD_CERT";    KEY_PEM="$PROD_KEY" ;;
              *) echo "Unknown ENV"; exit 1 ;;
            esac
            test -n "$TA_PEM" && test -n "$CRT_PEM" && test -n "$KEY_PEM" || { echo "Missing Linkerd issuer secrets for $ENV"; exit 1; }
          fi

          # Create/refresh Secret (issuer) & ConfigMap (trust roots)
          printf "%s" "$CRT_PEM" > /tmp/issuer.crt
          printf "%s" "$KEY_PEM" > /tmp/issuer.key
          printf "%s" "$TA_PEM"  > /tmp/trust-anchor.crt

          kubectl -n linkerd create secret tls linkerd-identity-issuer \
            --cert=/tmp/issuer.crt --key=/tmp/issuer.key \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl -n linkerd create configmap linkerd-identity-trust-roots \
            --from-file=ca-bundle.crt=/tmp/trust-anchor.crt \
            --dry-run=client -o yaml | kubectl apply -f -

          # produce a tiny values file for dev (externalCA mode, CNI enabled)
          if [ "$ENV" = "dev" ]; then
            mkdir -p helm-values/dev
            {
              echo "installNamespace: false"
              echo "controllerReplicas: 1"
              echo "cniEnabled: true"
              echo "identity:"
              echo "  externalCA: true"
              echo "identityTrustAnchorsPEM: |"
              sed 's/^/  /' /tmp/trust-anchor.crt
              echo "proxy:"
              echo "  resources:"
              echo "    requests: { cpu: 20m, memory: 64Mi }"
              echo "    limits:   { cpu: 200m, memory: 256Mi }"
            } > helm-values/dev/control-plane-values.yaml

            # Commit if changed (so Argo can read it from repo)
            if ! git diff --quiet -- helm-values/dev/control-plane-values.yaml; then
              git config user.name  "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add helm-values/dev/control-plane-values.yaml
              git commit -m "ci($ENV): write Linkerd externalCA values (CNI on)"
              git push origin "$DEFAULT_BRANCH"
            fi
          fi

      # ---------- Apply Argo CD Project ----------
      - name: Apply Argo CD Project
        run: kubectl apply -f argocd/project-platform-tools.yaml

      # ---------- Create/Apply Argo CD Applications (CRDs, CNI, control-plane, viz) ----------
      - name: Create/Apply Argo CD Applications
        env:
          ENV: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          set -euo pipefail

          # CRDs (wave -2)
          cat > /tmp/linkerd-crds.yaml <<'APP'
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: linkerd-crds-__ENV__
            namespace: argocd
            annotations:
              argocd.argoproj.io/sync-wave: "-2"
          spec:
            project: platform-tools
            source:
              repoURL: https://helm.linkerd.io/stable
              chart: linkerd-crds
              targetRevision: "*"
            destination:
              server: https://kubernetes.default.svc
              namespace: linkerd
            syncPolicy:
              automated: { selfHeal: true, prune: true }
              syncOptions: [ CreateNamespace=true ]
          APP
          sed -i "s/__ENV__/$ENV/g" /tmp/linkerd-crds.yaml
          kubectl apply -f /tmp/linkerd-crds.yaml

          # CNI (wave -1) -> avoids privileged proxy-init
          cat > /tmp/linkerd-cni.yaml <<'APP'
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: linkerd-cni-__ENV__
            namespace: argocd
            annotations:
              argocd.argoproj.io/sync-wave: "-1"
          spec:
            project: platform-tools
            source:
              repoURL: https://helm.linkerd.io/stable
              chart: linkerd-cni
              targetRevision: "*"
              helm:
                values: |
                  installNamespace: true
            destination:
              server: https://kubernetes.default.svc
              namespace: linkerd-cni
            syncPolicy:
              automated: { selfHeal: true, prune: true }
              syncOptions: [ CreateNamespace=true ]
          APP
          sed -i "s/__ENV__/$ENV/g" /tmp/linkerd-cni.yaml
          kubectl apply -f /tmp/linkerd-cni.yaml

          # Control plane (wave 0) â€“ externalCA, cniEnabled
          if [ "$ENV" = "dev" ]; then
            # build Application with inline values from repo file
            {
              echo "apiVersion: argoproj.io/v1alpha1"
              echo "kind: Application"
              echo "metadata:"
              echo "  name: linkerd-control-plane-dev"
              echo "  namespace: argocd"
              echo "  annotations:"
              echo "    argocd.argoproj.io/sync-wave: \"0\""
              echo "spec:"
              echo "  project: platform-tools"
              echo "  sources:"
              echo "    - repoURL: https://github.com/${{ github.repository }}"
              echo "      targetRevision: ${DEFAULT_BRANCH}"
              echo "      path: argocd/rbac"
              echo "    - repoURL: https://helm.linkerd.io/stable"
              echo "      chart: linkerd-control-plane"
              echo "      targetRevision: \"*\""
              echo "      helm:"
              echo "        values: |"
              sed 's/^/          /' helm-values/dev/control-plane-values.yaml
              echo "  destination:"
              echo "    server: https://kubernetes.default.svc"
              echo "    namespace: linkerd"
              echo "  syncPolicy:"
              echo "    automated: { selfHeal: true, prune: true }"
              echo "    syncOptions: [ CreateNamespace=true ]"
              echo "  ignoreDifferences:"
              echo "    - group: admissionregistration.k8s.io"
              echo "      kind: MutatingWebhookConfiguration"
              echo "      jqPathExpressions: [\".webhooks[]?.clientConfig.caBundle\"]"
            } | kubectl apply -f -
          else
            # staging/prod inline certs
            case "$ENV" in
              staging)
                TA="${{ secrets.LINKERD_STAGING_TRUST_ANCHOR_PEM }}"
                CRT="${{ secrets.LINKERD_STAGING_ISSUER_CERT_PEM }}"
                KEY="${{ secrets.LINKERD_STAGING_ISSUER_KEY_PEM }}"
                ;;
              prod)
                TA="${{ secrets.LINKERD_PROD_TRUST_ANCHOR_PEM }}"
                CRT="${{ secrets.LINKERD_PROD_ISSUER_CERT_PEM }}"
                KEY="${{ secrets.LINKERD_PROD_ISSUER_KEY_PEM }}"
                ;;
            esac

            cat > /tmp/linkerd-control-plane.yaml <<APP
            apiVersion: argoproj.io/v1alpha1
            kind: Application
            metadata:
              name: linkerd-control-plane-$ENV
              namespace: argocd
              annotations:
                argocd.argoproj.io/sync-wave: "0"
            spec:
              project: platform-tools
              sources:
                - repoURL: https://github.com/${{ github.repository }}
                  targetRevision: ${DEFAULT_BRANCH}
                  path: argocd/rbac
                - repoURL: https://helm.linkerd.io/stable
                  chart: linkerd-control-plane
                  targetRevision: "*"
                  helm:
                    values: |
                      installNamespace: false
                      controllerReplicas: $([ "$ENV" = "prod" ] && echo 3 || echo 2)
                      cniEnabled: true
                      identity:
                        externalCA: true
                      identityTrustAnchorsPEM: |
            APP
            # add TA indented 6 spaces
            echo "$TA" | sed 's/^/                        /' >> /tmp/linkerd-control-plane.yaml
            cat >> /tmp/linkerd-control-plane.yaml <<APP

              destination:
                server: https://kubernetes.default.svc
                namespace: linkerd
              syncPolicy:
                automated: { selfHeal: true, prune: true }
                syncOptions: [ CreateNamespace=true ]
              ignoreDifferences:
                - group: admissionregistration.k8s.io
                  kind: MutatingWebhookConfiguration
                  jqPathExpressions: [ ".webhooks[]?.clientConfig.caBundle" ]
            APP
            kubectl apply -f /tmp/linkerd-control-plane.yaml
          fi

          # Viz (wave +1)
          cat > /tmp/linkerd-viz.yaml <<'APP'
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: linkerd-viz-__ENV__
            namespace: argocd
            annotations:
              argocd.argoproj.io/sync-wave: "+1"
          spec:
            project: platform-tools
            source:
              repoURL: https://helm.linkerd.io/stable
              chart: linkerd-viz
              targetRevision: "*"
              helm:
                values: |
                  installNamespace: false
            destination:
              server: https://kubernetes.default.svc
              namespace: linkerd-viz
            syncPolicy:
              automated: { selfHeal: true, prune: true }
              syncOptions: [ CreateNamespace=true ]
          APP
          sed -i "s/__ENV__/$ENV/g" /tmp/linkerd-viz.yaml
          kubectl apply -f /tmp/linkerd-viz.yaml

      # ---------- Force sync ----------
      - name: Trigger syncs (CRDs, CNI, control-plane, viz)
        env:
          ENV: ${{ github.event.inputs.environment || 'dev' }}
        run: |
          set -e
          apps=(linkerd-crds-$ENV linkerd-cni-$ENV linkerd-control-plane-$ENV linkerd-viz-$ENV)
          # dev names match -dev
          if [ "$ENV" = "dev" ]; then
            apps=(linkerd-crds-dev linkerd-cni-dev linkerd-control-plane-dev linkerd-viz-dev)
          fi
          for a in "${apps[@]}"; do
            kubectl -n argocd patch application "$a" --type merge -p '{"operation":{"sync":{}}}' || true
          done

      # ---------- Waits ----------
      - name: Wait for Linkerd control plane
        run: |
          kubectl get ns linkerd >/dev/null 2>&1 || { echo "linkerd ns missing (yet)"; exit 0; }
          kubectl -n linkerd get deploy -o name | xargs -r -I{} kubectl -n linkerd wait --for=condition=available --timeout=15m {}

      - name: Wait for Linkerd Viz
        run: |
          kubectl get ns linkerd-viz >/dev/null 2>&1 || { echo "linkerd-viz ns missing (yet)"; exit 0; }
          kubectl -n linkerd-viz get deploy -o name | xargs -r -I{} kubectl -n linkerd-viz wait --for=condition=available --timeout=10m {}

      - name: Show status
        run: |
          echo "== Argo CD Apps =="
          kubectl -n argocd get applications
          echo "== Linkerd Control Plane =="
          kubectl -n linkerd get deploy,po -o wide || true
          echo "== Linkerd Viz =="
          kubectl -n linkerd-viz get deploy,po -o wide || true
