name: Deploy Linkerd via Argo CD (SealedSecrets/GitOps)

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: Environment to deploy
        default: dev
        options: [dev, staging, prod]
  push:
    branches: [ master ]
    paths:
      - 'argocd/**'
      - 'helm-values/**'
      - '.github/workflows/deploy-argocd-linkerd.yml'

env:
  PROJECT_ID: idp-0903
  GKE_CLUSTER: lowcost-gke-ondemand
  GKE_ZONE: us-central1-a
  DEFAULT_BRANCH: master
  REPO_SLUG: nolet7/linkered

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ----- gcloud + auth -----
      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '>= 475.0.0'

      - name: Auth with service account
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Install GKE auth plugin
        run: gcloud components install gke-gcloud-auth-plugin -q

      - name: Get GKE credentials
        run: |
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
          gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_ZONE" --project "$PROJECT_ID"

      - name: Select ENV
        id: envpick
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            ENV="dev"
          fi
          echo "ENV=$ENV" | tee -a $GITHUB_ENV

      # ----- Apply Argo CD project and SealedSecrets app from your repo -----
      - name: Apply Argo CD Project & SealedSecrets App
        run: |
          set -euo pipefail
          kubectl apply -f argocd/project-platform-tools.yaml
          kubectl apply -f argocd/apps/sealed-secrets.yaml

      - name: Wait for SealedSecrets controller
        run: |
          kubectl -n sealed-secrets rollout status deploy/sealed-secrets --timeout=5m

      # ----- Download kubeseal (used to seal issuer secret) -----
      - name: Install kubeseal
        run: |
          set -euo pipefail
          VER=$(curl -s https://api.github.com/repos/bitnami-labs/sealed-secrets/releases/latest | grep tag_name | cut -d'"' -f4)
          curl -L -o kubeseal "https://github.com/bitnami-labs/sealed-secrets/releases/download/${VER}/kubeseal-${VER#v}-linux-amd64"
          chmod +x kubeseal
          sudo mv kubeseal /usr/local/bin/
          kubeseal --version

      # ===== DEV ONLY: generate trust anchor & issuer, seal issuer, update values =====
      - name: (DEV) Generate trust anchor + issuer, seal issuer, commit to repo
        if: env.ENV == 'dev'
        run: |
          set -euo pipefail

          # 1) Generate trust anchor & issuer (ephemeral in CI)
          mkdir -p /tmp/linkerd-dev
          openssl req -x509 -newkey rsa:4096 -days 3650 -nodes \
            -keyout /tmp/linkerd-dev/ca.key -out /tmp/linkerd-dev/trust-anchor.crt \
            -subj "/CN=linkerd-trust-anchor.dev"

          openssl req -new -newkey rsa:4096 -nodes \
            -keyout /tmp/linkerd-dev/issuer.key -out /tmp/linkerd-dev/issuer.csr \
            -subj "/CN=linkerd-identity-issuer.dev"

          openssl x509 -req -in /tmp/linkerd-dev/issuer.csr \
            -CA /tmp/linkerd-dev/trust-anchor.crt -CAkey /tmp/linkerd-dev/ca.key -CAcreateserial \
            -out /tmp/linkerd-dev/issuer.crt -days 3650

          # 2) Prepare plain TLS Secret manifest (not applied; just used to seal)
          kubectl -n linkerd create secret tls linkerd-identity-issuer \
            --cert=/tmp/linkerd-dev/issuer.crt --key=/tmp/linkerd-dev/issuer.key \
            --dry-run=client -o yaml > /tmp/issuer-secret.yaml

          # 3) Fetch cluster's SealedSecrets public cert, seal the secret
          kubeseal --controller-namespace sealed-secrets --controller-name sealed-secrets \
            --fetch-cert > /tmp/sealed-secrets.crt

          mkdir -p argocd/linkerd-ca
          kubeseal --cert /tmp/sealed-secrets.crt --format yaml < /tmp/issuer-secret.yaml \
            > argocd/linkerd-ca/linkerd-identity-issuer.sealedsecret.yaml

          # 4) Write dev Helm values with the public trust anchor
          mkdir -p helm-values/dev
          cat > helm-values/dev/control-plane-values.yaml <<'EOF_HEAD'
          installNamespace: false
          cniEnabled: true
          controllerReplicas: 1

          identity:
            # Linkerd will mount a pre-created Secret named linkerd-identity-issuer.
            issuer:
              scheme: kubernetes.io/tls

          identityTrustAnchorsPEM: |
          EOF_HEAD
          # Append the actual trust anchor with correct indentation
          sed 's/^/  /' /tmp/linkerd-dev/trust-anchor.crt >> helm-values/dev/control-plane-values.yaml

          cat >> helm-values/dev/control-plane-values.yaml <<'EOF_TAIL'

          proxy:
            resources:
              requests: { cpu: 50m, memory: 128Mi }
              limits:   { cpu: 500m, memory: 512Mi }
          EOF_TAIL

          # 5) Commit any changes (sealed secret + values)
          if ! git diff --quiet -- argocd/linkerd-ca/linkerd-identity-issuer.sealedsecret.yaml helm-values/dev/control-plane-values.yaml; then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add argocd/linkerd-ca/linkerd-identity-issuer.sealedsecret.yaml helm-values/dev/control-plane-values.yaml
            git commit -m "ci(dev): generate trust anchor & issuer; seal issuer; update dev values"
            git push origin "$DEFAULT_BRANCH"
          fi

      # ----- Apply remaining Argo CD apps from your repo -----
      - name: Apply Linkerd Argo CD Applications
        run: |
          set -euo pipefail
          # CRDs
          kubectl apply -f argocd/apps/linkerd-crds-dev.yaml
          # Sealed issuer secret app (reads argocd/linkerd-ca/)
          kubectl apply -f argocd/apps/linkerd-identity-secrets-dev.yaml
          # Control plane + Viz
          kubectl apply -f argocd/apps/linkerd-control-plane-dev.yaml
          kubectl apply -f argocd/apps/linkerd-viz-dev.yaml

      # ----- Ensure sync-waves annotation are set (optional safeguard) -----
      - name: Ensure sync waves (CRDs -2, secrets 0, control-plane 1, viz 2)
        run: |
          set -euo pipefail
          kubectl -n argocd patch application linkerd-crds-dev --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/sync-wave":"-2"}}}'
          kubectl -n argocd patch application linkerd-identity-secrets-dev --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/sync-wave":"0"}}}'
          kubectl -n argocd patch application linkerd-control-plane-dev --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/sync-wave":"1"}}}'
          kubectl -n argocd patch application linkerd-viz-dev --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/sync-wave":"2"}}}'

          # Auto-sync & self heal everywhere
          for a in linkerd-crds-dev linkerd-identity-secrets-dev linkerd-control-plane-dev linkerd-viz-dev; do
            kubectl -n argocd patch application "$a" --type merge -p \
              '{"spec":{"syncPolicy":{"automated":{"selfHeal":true,"prune":true},"syncOptions":["CreateNamespace=true"]}}}'
          done

          # Kick off syncs
          for a in linkerd-crds-dev linkerd-identity-secrets-dev linkerd-control-plane-dev linkerd-viz-dev; do
            kubectl -n argocd patch application "$a" --type merge -p '{"operation":{"sync":{}}}'
          done

      # ----- Wait for readiness -----
      - name: Wait for Linkerd control plane
        run: |
          kubectl get ns linkerd >/dev/null 2>&1 || { echo "linkerd namespace not created yet"; exit 0; }
          kubectl -n linkerd get deploy -o name | xargs -r -I{} kubectl -n linkerd wait --for=condition=available --timeout=10m {}

      - name: Wait for Linkerd Viz
        run: |
          kubectl get ns linkerd-viz >/dev/null 2>&1 || { echo "linkerd-viz namespace not created yet"; exit 0; }
          kubectl -n linkerd-viz get deploy -o name | xargs -r -I{} kubectl -n linkerd-viz wait --for=condition=available --timeout=10m {}

      - name: Show status
        run: |
          echo "== Argo CD Applications =="
          kubectl -n argocd get applications
          echo "== Linkerd =="
          kubectl -n linkerd get deploy,po -o wide || true
          echo "== Linkerd Viz =="
          kubectl -n linkerd-viz get deploy,po -o wide || true
